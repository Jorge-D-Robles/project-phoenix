PROJECT PHOENIX: UNIFIED PRODUCTIVITY ECOSYSTEM TECHNICAL SPECIFICATION1. Architectural Vision and System Design Principles1.1 Executive Summary and System PhilosophyProject Phoenix represents a paradigm shift in personal productivity software, moving away from fragmented, siloed applications toward a unified "Client-Centric Aggregator" model. The core objective is to synthesize disparate information streams—specifically Google Tasks, Calendar events, Keep-style notes, and Google Docs—into a single, coherent operational dashboard. This system is distinct in its inclusion of a GitHub-style habit tracking heatmap, merging quantitative behavioral data with qualitative task management.The architecture is predicated on an "Agent-First" design philosophy. This document serves not merely as a guide for human developers but as a deterministic instruction set for autonomous AI software engineering agents. Consequently, the specification prioritizes explicit state management patterns, strict typing systems, and verifiable data contracts over abstract user stories. The system targets two distinct client platforms: a Progressive Web Application (PWA) leveraging Angular 19+ with Signals, and a native Android application built with Kotlin and Jetpack Compose. These platforms are linked not by a proprietary backend, but by a shared data ontology and direct integration with Google Workspace APIs, ensuring user data sovereignty and privacy.1.2 The Client-Centric Aggregator ModelTraditional SaaS architectures typically rely on a proprietary intermediary server to proxy requests between the client and third-party APIs. Project Phoenix rejects this model in favor of a "thick client" architecture where the browser (Web) or device (Android) acts as the primary orchestration engine. This decision mitigates infrastructure costs and enhances privacy, as data resides either on the user's local device or within their authenticated Google storage.In this model, the application logic is responsible for maintaining a "Local Source of Truth" that is optimistically synchronized with the "Remote Source of Truth" (Google's servers). The complexity of this architecture lies in the synchronization engine, which must handle network partitions, rate limiting , and data conflict resolution without a central coordination server. The system treats the Google Drive "Application Data Folder" as a pseudo-backend for storing configuration state and non-API-supported data types, such as the habit tracker logs and proprietary note formats.1.3 Cross-Platform Technology StackThe technology selection for Project Phoenix is driven by the requirement for robust typing, reactive state management, and offline capability.Web Platform (Angular 19+)
The frontend utilizes Angular 19, specifically leveraging the new reactivity primitives (Signals) to eliminate the overhead of zone.js. This choice aligns with the industry trend toward fine-grained reactivity, offering superior performance for the complex DOM manipulations required by the habit heatmap. The build system relies on esbuild for rapid compilation, ensuring the development lifecycle remains efficient for AI agents iterating on code.Android Platform (Native Kotlin)
The mobile client is a native Android application, avoiding cross-platform frameworks like Flutter or React Native to ensure maximum performance and seamless integration with system-level features like widgets and background sync services. The UI is built entirely in Jetpack Compose, mapping the declarative paradigms of Angular to Kotlin. The "Offline-First" requirement mandates the use of Room Persistence Library (SQLite) as the single source of truth for the UI, with WorkManager handling asynchronous synchronization.1.4 Agentic Implementation StrategyThis specification is structured to be consumed by AI agents. Agents operate most effectively when given "Guardrails" and "Structured Context". Therefore, this document provides:Semantic Data Models: JSON schemas that define the exact shape of every entity.Deterministic State Transitions: Explicit rules for how data moves from "Loading" to "Success" or "Error" states.Transposition Mapping: A precise dictionary mapping Web concepts (Services, Signals) to Android concepts (Repositories, StateFlows) to facilitate code translation.2. Domain Modeling and Data OntologyThe integrity of Project Phoenix relies on a rigorous data ontology that normalizes the eccentricities of external APIs into a coherent internal schema. These models serve as the contract for both the Angular interfaces and the Kotlin data classes.2.1 The Unified Task EntityThe Task entity is the atomic unit of the system. It aggregates fields from Google Tasks while appending metadata required for the Phoenix ecosystem, such as habit association and rich-text linking. Since Google Tasks does not natively support custom metadata fields in its standard API, we utilize a "description-packing" strategy where metadata is serialized into a JSON string and appended to the task's notes field, delimited by a unique marker.Schema Definition:The internal representation of a task must strictly adhere to the following structure. Agents must ensure that all date-time fields are normalized to ISO 8601 UTC strings before persistence or transmission.Field NameData TypeNullableSourceDescriptionidStringNoGoogleThe unique identifier provided by the Google Tasks API.localIdStringNoPhoenixA UUID v4 generated locally to track optimistic creations before server sync.titleStringNoGoogleThe user-facing content of the task.statusEnumNoGoogleValues: needsAction, completed. Maps to internal booleans.dueDateTimeYesGoogleRFC 3339 timestamp. Note: Google Tasks API often discards time, keeping only date.notesStringYesGoogleThe raw text description. Contains the "Phoenix Meta Block" at the end.metaObjectYesPhoenixParsed JSON object containing habitId, docLinks, and tags.parentStringYesGoogleID of the parent task if this is a subtask.positionStringNoGoogleLexicographical string used for sorting order among siblings.updatedDateTimeNoGoogleTimestamp of the last server-side modification.isDirtyBooleanNoPhoenixFlag indicating local modification not yet synced to server (Android only).isDeletedBooleanNoPhoenixSoft-delete flag for sync resolution (Android only).Implications for Agents:When implementing the TaskParser skill, the agent must write regex logic to extract the meta object from the notes field. The pattern to be used is \n---PHOENIX_META---\n{...json...}. This ensures that the metadata remains invisible to the casual user in the standard Google Tasks interface while being machine-readable by Project Phoenix.2.2 The Habit Definition and Log EntityHabit tracking is a proprietary feature of Phoenix, as it does not map directly to a Google API. These entities are stored in a habits.json file located in the user's Google Drive Application Data Folder. This folder is hidden from the user's standard Drive UI, preventing accidental deletion or corruption.Habit Definition Schema:JSON{
  "type": "object",
  "properties": {
    "id": { "type": "string", "format": "uuid" },
    "title": { "type": "string", "minLength": 1 },
    "frequency": { "type": "string", "enum": },
    "targetValue": { "type": "integer", "minimum": 1, "description": "Goal count per period" },
    "color": { "type": "string", "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$" },
    "archived": { "type": "boolean", "default": false },
    "created": { "type": "string", "format": "date-time" },
    "lastModified": { "type": "string", "format": "date-time" }
  }
}
Habit Log Schema:The log entity records the execution of a habit. To optimize for the heatmap visualization, logs are stored as a sparse array of events rather than a daily record of zeroes.JSON{
  "type": "object",
  "properties": {
    "habitId": { "type": "string", "format": "uuid" },
    "date": { "type": "string", "format": "date", "description": "YYYY-MM-DD" },
    "value": { "type": "integer", "description": "The magnitude of the contribution" }
  }
}
2.3 The Phoenix Note Entity (The Keep Surrogate)A critical limitation identified in the research is that the Google Keep API is restricted to Enterprise environments and not available to personal Gmail accounts. To satisfy the requirement for note integration without violating API access policies, Project Phoenix introduces the "Phoenix Note."Phoenix Notes are JSON files stored in a user-designated "Phoenix_Notes" folder in Google Drive (distinct from the AppData folder to allow user access via Drive UI). This approach allows the app to read/write notes while giving the user ownership of the files.Phoenix Note Schema:JSON{
  "type": "object",
  "properties": {
    "id": { "type": "string", "description": "Google Drive File ID" },
    "title": { "type": "string" },
    "content": { "type": "string", "description": "HTML or Markdown content" },
    "labels": { "type": "array", "items": { "type": "string" } },
    "color": { "type": "string", "enum": },
    "attachments": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "fileId": { "type": "string" },
          "mimeType": { "type": "string" },
          "webViewLink": { "type": "string" }
        }
      }
    }
  }
}
This schema closely mimics the Google Keep data structure , allowing for a potential future migration if the API becomes public, while currently relying on the permissive drive.file scope.3. External Integration SpecificationDirect integration with Google Workspace APIs requires careful handling of authentication flows, quota management, and error handling. This section details the protocol for each service.3.1 Authentication and Security ArchitectureThe system employs OAuth 2.0 with Proof Key for Code Exchange (PKCE) for both Web and Android clients. This is the industry standard for securing public clients.Scope Strategy:
To maximize user trust and conversion, the application uses an "Incremental Authorization" strategy. Scopes are requested only when the specific feature is accessed.Baseline Scope: openid, email, profile. Requested on login.Task Scope: https://www.googleapis.com/auth/tasks. Requested when the user clicks the "Tasks" tab.Calendar Scope: https://www.googleapis.com/auth/calendar.events. Requested when accessing the "Schedule" view.Drive Scope: https://www.googleapis.com/auth/drive.file and https://www.googleapis.com/auth/drive.appdata. Requested for Notes and Backup configuration.Agent Instruction: Agents must implement an AuthInterceptor (Web) and AuthAuthenticator (Android/OkHttp) that detects 401 Unauthorized responses. Upon detection, the system must attempt to refresh the access token using the stored refresh token. If the refresh fails (e.g., token revoked), the user must be redirected to the login screen.3.2 Google Tasks Service IntegrationThe Google Tasks API is RESTful but contains specific nuances regarding list management and task positioning.Service Interface (TypeScript/Kotlin):listTaskLists(): Retrieving the user's lists is the first step. The "default" list is usually the primary target.getTasks(listId, showCompleted=false): Fetches tasks. Pagination via pageToken is mandatory.moveTask(listId, taskId, parentId, previousId): This method is critical for the "Drag and Drop" functionality. The API requires both parentId (for nesting) and previousId (for ordering). Agents must implement logic to calculate these IDs based on the drop target in the UI.Quota Management:Google Tasks has a quota on queries per minute. The TaskService must implement a "Leaky Bucket" rate limiter or simple exponential backoff. If a 429 Too Many Requests is received, the system waits $2^n + \text{random\_jitter}$ seconds before retrying.3.3 Google Calendar IntegrationThe Calendar integration focuses on the "Day View" to provide context for tasks.Sync Strategy:Unlike Tasks, Calendar data can be voluminous. The integration relies on the syncToken provided by the events.list endpoint.Initial Sync: Fetch events for timeMin=Now-30d and timeMax=Now+90d. Store the nextSyncToken.Incremental Sync: On subsequent loads, pass the stored syncToken. The API returns only modified events (new, updated, cancelled). This significantly reduces bandwidth usage.Data Mapping:Calendar events must be mapped to a readonly PhoenixEvent entity.Google Event Color must be mapped to the Phoenix CSS/Material color palette.HTML Description in events must be sanitized before rendering to prevent XSS.3.4 Google Docs and Drive IntegrationThe integration with Google Docs is primarily "Referential." Project Phoenix does not build a full-featured word processor but acts as a launcher and organizer.API Usage:Search: Use the q parameter in the Drive API to filter by MIME type application/vnd.google-apps.document.Creation: Use the files.create method with application/vnd.google-apps.document MIME type.Linking: When a user attaches a Doc to a Task, the app stores the webViewLink and iconLink in the task's metadata.4. Web Application Specification (Angular 19+)The web client is the flagship interface, utilizing the latest advancements in the Angular framework to deliver a performant, responsive experience.4.1 Macro-Architecture and Workspace LayoutThe application is structured as a "Modular Monolith" within a standard Angular CLI workspace. We avoid strict micro-frontends to reduce complexity but enforce module boundaries via library separation (Nx-style architecture is recommended but CLI standard is acceptable).Directory Structure:src/app/core: Singleton services (Auth, HTTP, Logging).src/app/data: Types, Interfaces, API Clients (The Data Layer).src/app/state: SignalStores for global state.src/app/features:dashboard: The home view with summary widgets.tasks: Task management logic.calendar: Calendar view components.habits: Tracker and heatmap logic.notes: Drive-based note management.src/app/shared: Reusable UI components (Buttons, Dialogs, Pipes).4.2 State Management: The SignalStore RevolutionProject Phoenix eschews the traditional RxJS-heavy NgRx pattern in favor of SignalStore (inspired by @ngrx/signals). This aligns with the "Zoneless" future of Angular.Why SignalStore?
Signals provide fine-grained reactivity. When a single task's status changes, only the specific DOM node bound to that signal updates, rather than triggering a check of the entire component tree. This is critical for the performance of the Habit Heatmap, which may contain 365+ individual cells.Store Definition Example (Agent Instruction):Agents must define stores that expose state, computed signals, and methods.TypeScriptexport const TasksStore = signalStore(
  { providedIn: 'root' },
  withState({ tasks:, loading: false, filter: 'ALL' }),
  withComputed(({ tasks, filter }) => ({
    filteredTasks: computed(() => {
        // Logic to filter tasks based on the filter signal
        return tasks().filter(...)
    }),
    completionRate: computed(() => {
        // Logic to calculate stats
    })
  })),
  withMethods((store, taskService = inject(TaskService)) => ({
    async loadTasks() {
      patchState(store, { loading: true });
      const data = await taskService.getTasks();
      patchState(store, { tasks: data, loading: false });
    }
  }))
);
4.3 Component Design and SignalsComponents must be Standalone and utilize the OnPush change detection strategy (or strictly ChangeDetectionStrategy.OnPush if not fully zoneless).Inputs as Signals:
Angular 19 introduces input() signals. All components must use this pattern instead of the @Input decorator.Legacy: @Input() data: Task;Phoenix Standard: data = input.required<Task>();View Integration:The Habit Heatmap component requires dynamic rendering.Grid Layout: Use CSS Grid with grid-template-rows: repeat(7, 1fr) and grid-auto-flow: column. This ensures the heatmap fills vertically (Sunday to Saturday) before moving to the next week column, matching the GitHub standard.Cell Component: A dumb component taking level (0-4) as an input signal. The level determines the background color intensity using Angular Material colors (e.g., mat-sys-primary-container variants).4.4 Styling and Theming (Material 3)The application uses Angular Material 18+, which supports Material 3 Design Tokens.Theming: Define a custom theme using the mat.define-theme() mixin.Dark Mode: Implement a ThemeService that toggles a class on the body element. Use CSS variables for all color definitions to ensure seamless switching between light and dark modes.5. Native Android Specification (Transposition Strategy)The Android client mirrors the Web client's functionality but is architected using native mobile paradigms. The key instruction for agents is the "Transposition" of Angular concepts to Kotlin/Compose concepts.5.1 Architecture: Offline-First MVVMUnlike the Web app, which may rely on browser caching, the Android app must be fully functional offline.Architecture Layers:UI Layer: Jetpack Compose (Activities, Screens).Presentation Layer: ViewModels holding StateFlows.Domain Layer: Use Cases (optional, effectively "Services" in Angular).Data Layer:Repository: Arbitrates data access.Local DataSource: Room Database (SQLite).Remote DataSource: Retrofit (HTTP Client).5.2 Mapping Angular Concepts to Jetpack ComposeTo implement the spec "from scratch," agents must understand the translation table between the two platforms.Angular ConceptAndroid/Kotlin EquivalentImplementation NotesComponentComposable Function@Composable fun TaskList(...)Template (HTML)Compose UI TreeColumn { Text(...) }Signal / InputState / Parameterval tasks by viewModel.tasks.collectAsState()ServiceRepositorySingleton managed by Hilt (DI).Directive (@if, @for)Control Flowif (...) { }, items(...) { }PipeExtension Functionfun Date.toRelativeString(): StringDependency InjectionHilt / Dagger@Inject constructor(...)Lifecycle (ngOnInit)LaunchedEffectLaunchedEffect(Unit) { viewModel.load() }5.3 Local Persistence: Room DatabaseThe database schema must mirror the JSON schema but utilize SQL relational integrity.Entity Definition (Kotlin):Kotlin@Entity(tableName = "tasks")
data class TaskEntity(
    @PrimaryKey val id: String,
    val title: String,
    val isCompleted: Boolean,
    val dueDate: Long?,
    val isDirty: Boolean = false, // Critical for sync
    val isDeleted: Boolean = false // Soft delete
)
Agents Instruction: Create a TypeConverter for storing the meta JSON object as a String in the SQLite database, and parse it back to a Data Class upon reading.5.4 Synchronization Engine (WorkManager)Synchronization on Android is handled by WorkManager, which guarantees execution even if the app is closed.Sync Strategy (The "Delta" Approach):Pull: Fetch all tasks from Google API modified after last_sync_timestamp.Merge:If Remote.updated > Local.updated: Overwrite local.If Local.updated > Remote.updated AND Local.isDirty: Conflict. Strategy: Server Wins (safest for MVP) or duplicate the local task as a "Conflict Copy."Push: Query Room for isDirty == true. POST/PATCH these tasks to Google API. Upon 200 OK, set isDirty = false.5.5 UI Implementation detailsNavigation: Use androidx.navigation.compose with type-safe routes.Habit Heatmap: Unlike the DOM, Compose uses a Canvas for high-performance drawing.Agent Instruction: Implement a Canvas composable. Calculate the x/y coordinates for each square based on (WeekIndex * Size) and (DayIndex * Size). Use drawRect for rendering. This is significantly more performant than creating 365 Box composables.6. The Habit Tracker Heatmap AlgorithmThe visual centerpiece of Project Phoenix is the contribution graph. The logic for generating this graph is shared conceptually but implemented natively on each platform.6.1 Mathematical LogicThe heatmap represents a rolling window of 52 weeks (approx. 365 days).Normalization: Determine the MaxValue in the dataset to establish the color scale ceiling.Scale: 4 Quartiles.Level 0: 0Level 1: 1 to 0.25 * MaxLevel 2: 0.25 * Max to 0.50 * MaxLevel 3: 0.50 * Max to 0.75 * MaxLevel 4: > 0.75 * MaxGrid Positioning:WeekIndex = Floor(DayDifference / 7)DayIndex = DayDifference % 7 (Where DayDifference is days since StartDate).Locale Handling: The system must respect the user's start of the week (Monday vs. Sunday). This shifts the DayIndex calculation.7. Agentic Skills and InstructionsThis section defines the specific capabilities (Skills) that the AI agents must instantiate to execute this specification. This is the "Meta-Prompting" layer.7.1 Skill: API Schema Ingestion and TypingCapability: The agent must be able to ingest the discovery.json from Google APIs and auto-generate:TypeScript Interfaces (task.model.ts).Kotlin Data Classes (TaskDto.kt) with @SerializedName annotations.Instruction: "Analyze the provided JSON response sample. Generate a strictly typed interface. Ensure optional fields are marked with ? or Nullable. Do not use any or Object."7.2 Skill: The "Transpose" Pattern (Angular to Compose)Capability: The ability to look at an Angular HTML template and equivalent SCSS, and generate a Jetpack Compose modifier chain.Instruction: "Read the CSS class .task-card { padding: 16px; border-radius: 8px; background: white; }. Generate a Kotlin Modifier: Modifier.padding(16.dp).clip(RoundedCornerShape(8.dp)).background(Color.White)."7.3 Skill: Defensive Coding for QuotasCapability: Implementing retry logic.Instruction: "Wrap all HTTP calls in a retryWhen (RxJS) or retry (Kotlin Flow) block. Detect 429 status codes. Implement a binary exponential backoff delay strategy."7.4 Skill: Documentation-Driven Development (DDD)Capability: Generating Mermaid.js diagrams before writing code.Instruction: "Before implementing the SyncWorker, generate a Mermaid Sequence Diagram showing the interaction between the Local Database, the WorkManager, and the Remote API. Confirm the logic handles the 'Offline' state correctly.".8. Conclusion and Implementation RoadmapProject Phoenix is a sophisticated attempt to unify personal productivity through a "Client-Aggregator" architecture. By leveraging the specific strengths of Angular 19 (Signals, Standalone Components) and Android Native (Offline-First Room, Compose), the system achieves a balance of performance, privacy, and capability.The implementation path for the AI agents is clear:Foundations: Establish the Authentication layer (OAuth 2.0 PKCE) on both platforms.Data Layer: Implement the standardized Task, Habit, and Note entities and their local persistence mechanisms (Dexie.js for Web, Room for Android).Integration: Build the robust service wrappers for Google APIs, specifically the Drive-based workaround for Notes.UI Construction: Implement the Dashboard and Habit Heatmap using the platform-specific rendering techniques (CSS Grid vs. Compose Canvas).Synchronization: Activate the background sync engines to ensure data consistency.This specification acts as the immutable Single Source of Truth for the construction of this ecosystem.Citations and References:
 Google Keep API Limitations.
 OAuth 2.0 Standards.
 Google Calendar API Sync Tokens.
 Heatmap Visualization Logic.
 Angular Signals and State Management.
 Jetpack Compose and Material 3.
 Offline-First Architecture and WorkManager.
 Google Drive App Data Folder usage.
 Google Tasks API Structure.
